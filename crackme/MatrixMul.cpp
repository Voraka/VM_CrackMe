#include "stdafx.h"
#include "MatrixMul.h"
#include <memory>

CMatrixMul::CMatrixMul()
	: A(5, 5)
	, B(4, 4)
	, D(5, 4)
{
	A << 20, 17, 8, 9, 35,
		18, 15, 24, 37, 29,
		17, 19, 32, 16, 31,
		21, 25, 24, 27, 26,
		33, 31, 18, 15, 21;

	B << 81,42,	58,	46,
		69,	57,	62,	29,
		93,	63,	37,	72,
		39,	47,	65,	77;

	//C << 56470995,	41015877,	44439931,	44775738,
	//	90861459,	65861753,	69378119,	68955622,
	//	79269456,	56957266,	60781038,	60630504,
	//	89488155,	64632086,	68968619,	68654813,
	//	82657308,	59511385,	64351836,	64355884;

 
	D << 15079, 14081, 12546, 17625, 9095,
		13815, 13778, 20166, 13699, 16000,
		14469, 13730, 14541, 9941, 15719,
		15233, 16366, 14096, 14274, 13777;
}


CMatrixMul::~CMatrixMul()
{

}

bool CMatrixMul::MMulEqual(std::string strIn)
{
	size_t sz = base16EncodeGetLength(strIn.length());
	std::shared_ptr<char> ptrEnc(new char[sz], std::default_delete<char[]>());
	base16Encode(&*ptrEnc, strIn.c_str(), strIn.length());
	
	short* p = (short*)&*ptrEnc;
	// 定义矩阵X
	MatrixDI X(5, 4);
	X << *p, *(p + 1), *(p + 2), *(p + 3), *(p + 4), 
		*(p + 5), *(p + 6), *(p + 7), *(p + 8), *(p + 9), 
		*(p + 10), *(p + 11), *(p + 12), *(p + 13), *(p + 14), 
		*(p + 15), *(p + 16), *(p + 17), *(p + 18), *(p + 19);

	MatrixDI tmp(5, 5), tmp1(5,4);
	tmp << 56469006, 90859461, 79267457, 89486139, 82655295,
		41013878, 65859760, 56955275, 64630083, 59509383,
		44437936, 69376122, 60779038, 68966604, 64349818,
		44773746, 68953626, 60628503, 68652823, 64353867,
		0x2021, 0x2019, 0x2017, 0x2020, 0x2018;

	// 矩阵C == tmp的转置+tmp1
	//tmp.transposeInPlace();
	
	tmp1 << 1989,	1999,	1995,	1992,
		1998,	1993,	1997,	1996,
		1999,	1991,	2000,	2001,
		2016,	2003,	2015,	1990,
		2013,	2002,	2018,	2017;


	MatrixDI Y(5, 4);
	
	////// 此处用于生成正确的矩阵D的值
	//// 正确的X矩阵的值：
	//Y << 2517,	1587,	2096,	1769,
	//	4533,	1989,	2018,	3572,
	//	3251,	2480,	2741,	1168,
	//	2813,	4581,	3927,	2483,
	//	1758,	1314,	1520,	2017;
	//MXor(Y, X, D);
	//for (int i = 0; i < D.rows(); i++)
	//	for (int j = 0; j < D.cols(); j++)
	//		ATLTRACE("%d, ", D(i, j));
	
	MXor(D, X, Y);
	return (A*Y*B == tmp.transpose().block(0, 0, 5, 4) + tmp1);
}

// 两矩阵相异或（只适用于同型矩阵）
void CMatrixMul::MXor(const MatrixDI& A, const MatrixDI& B, MatrixDI& C)
{
	for (int i = 0; i < A.rows(); i++)
	{
		for (int j = 0; j < A.cols(); j++)
		{
			C(i, j) = A(i, j) ^ B(i, j);
		}
	}
}