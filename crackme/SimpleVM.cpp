#include "stdafx.h"
#include "SimpleVM.h"

namespace SVM
{
 #define __VM2__
	DWORD Stack[0x100] = { 0x78563412, 0x21436587 };
	BYTE op_encrypt1[0x52] = {
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ESI,
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ECX,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDI,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDX,
		CSimpleVM::EPSH_ECX, CSimpleVM::EPSH_EBX, CSimpleVM::ECMP,
		CSimpleVM::EJGE, 0x51,
		CSimpleVM::EPSH_MEM8, 0xE8, CSimpleVM::ENOT,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ELSHIFT, 1,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ERSHIFT, 7,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_ESI,
		CSimpleVM::ELDSB, CSimpleVM::EAND,CSimpleVM::EPSH_MEM8, 0xE8,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ENOT,
		CSimpleVM::EAND, CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_MEM16, 0x00, 0x01, CSimpleVM::EPSH_ESI,
		CSimpleVM::ELDSB, CSimpleVM::EPSH_EDX, CSimpleVM::EPSH_EBX,
		CSimpleVM::EMOD, CSimpleVM::ELDDSB, CSimpleVM::EADD, CSimpleVM::EMOD,
		CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_MEM8, 0x75,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ELSHIFT, 2,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,  CSimpleVM::ERSHIFT, 6,  CSimpleVM::EOR,
		CSimpleVM::EXOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EINC_EBX,
		CSimpleVM::EJMP, 0x18, 0
	};

	BYTE op_encrypt2[0x52] = {
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ESI,
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ECX,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDI,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDX,
		CSimpleVM::EPSH_ECX, CSimpleVM::EPSH_EBX, CSimpleVM::ECMP,
		CSimpleVM::EJGE, 0x51,
		CSimpleVM::EPSH_MEM8, 0x9B, CSimpleVM::ENOT,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ELSHIFT, 2,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ERSHIFT, 6,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_ESI,
		CSimpleVM::ELDSB, CSimpleVM::EAND,CSimpleVM::EPSH_MEM8, 0x9B,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ENOT,
		CSimpleVM::EAND, CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_MEM16, 0x00, 0x01, CSimpleVM::EPSH_ESI,
		CSimpleVM::ELDSB, CSimpleVM::EPSH_EDX, CSimpleVM::EPSH_EBX,
		CSimpleVM::EMOD, CSimpleVM::ELDDSB, CSimpleVM::EADD, CSimpleVM::EMOD,
		CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_MEM8, 0x6D,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ELSHIFT, 3,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,  CSimpleVM::ERSHIFT, 5,  CSimpleVM::EOR,
		CSimpleVM::EXOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EINC_EBX,
		CSimpleVM::EJMP, 0x18, 0
	};

	byte op_decrypt1[0x59] = {
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ESI,
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ECX,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDI,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDX,
		CSimpleVM::EPSH_ECX, CSimpleVM::EPSH_EBX, CSimpleVM::ECMP,
		CSimpleVM::EJGE, 0x58, CSimpleVM::EPSH_MEM8, 0x75,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::EXOR,
		CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ERSHIFT, 2,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ELSHIFT, 6,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_MEM16, 0x00, 0x01, CSimpleVM::EPSH_MEM16,
		0x00, 0x01,CSimpleVM::EPSH_EDX, CSimpleVM::EPSH_EBX,
		CSimpleVM::EMOD, CSimpleVM::ELDDSB,
		CSimpleVM::EPSH_ESI,CSimpleVM::ELDSB,
		CSimpleVM::ESUB, CSimpleVM::EADD, CSimpleVM::EMOD,
		CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,
		CSimpleVM::ENOT, CSimpleVM::EPSH_MEM8, 0xE8,
		CSimpleVM::EAND, CSimpleVM::EPSH_MEM8, 0xE8, CSimpleVM::ENOT,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::EAND,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ERSHIFT, 1,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,  CSimpleVM::ELSHIFT, 7,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EINC_EBX,
		CSimpleVM::EJMP, 0x18, 0
	};

	BYTE op_encrypt3[0x52] = {
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ESI,
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ECX,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDI,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDX,
		CSimpleVM::EPSH_ECX, CSimpleVM::EPSH_EBX, CSimpleVM::ECMP,
		CSimpleVM::EJGE, 0x51,
		CSimpleVM::EPSH_MEM8, 0x7B, CSimpleVM::ENOT,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ELSHIFT, 4,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ERSHIFT, 4,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_ESI,
		CSimpleVM::ELDSB, CSimpleVM::EAND,CSimpleVM::EPSH_MEM8, 0x7B,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ENOT,
		CSimpleVM::EAND, CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_MEM16, 0x00, 0x01, CSimpleVM::EPSH_ESI,
		CSimpleVM::ELDSB, CSimpleVM::EPSH_EDX, CSimpleVM::EPSH_EBX,
		CSimpleVM::EMOD, CSimpleVM::ELDDSB, CSimpleVM::EADD, CSimpleVM::EMOD,
		CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_MEM8, 0xAD,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ELSHIFT, 7,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,  CSimpleVM::ERSHIFT, 1,  CSimpleVM::EOR,
		CSimpleVM::EXOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EINC_EBX,
		CSimpleVM::EJMP, 0x18, 0
	};

	byte op_decrypt2[0x59] = {
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ESI,
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ECX,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDI,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDX,
		CSimpleVM::EPSH_ECX, CSimpleVM::EPSH_EBX, CSimpleVM::ECMP,
		CSimpleVM::EJGE, 0x58, CSimpleVM::EPSH_MEM8, 0x6D,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::EXOR,
		CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ERSHIFT, 3,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ELSHIFT, 5,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_MEM16, 0x00, 0x01, CSimpleVM::EPSH_MEM16,
		0x00, 0x01,CSimpleVM::EPSH_EDX, CSimpleVM::EPSH_EBX,
		CSimpleVM::EMOD, CSimpleVM::ELDDSB,
		CSimpleVM::EPSH_ESI,CSimpleVM::ELDSB,
		CSimpleVM::ESUB, CSimpleVM::EADD, CSimpleVM::EMOD,
		CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,
		CSimpleVM::ENOT, CSimpleVM::EPSH_MEM8, 0x9B,
		CSimpleVM::EAND, CSimpleVM::EPSH_MEM8, 0x9B, CSimpleVM::ENOT,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::EAND,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ERSHIFT, 2,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,  CSimpleVM::ELSHIFT, 6,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EINC_EBX,
		CSimpleVM::EJMP, 0x18, 0
	};

	byte op_decrypt3[0x59] = {
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ESI,
		CSimpleVM::EPSH_MEM, 0,0,0,0, CSimpleVM::EPOP_ECX,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDI,
		CSimpleVM::EPSH_MEM, 0,0,0,0,  CSimpleVM::EPOP_EDX,
		CSimpleVM::EPSH_ECX, CSimpleVM::EPSH_EBX, CSimpleVM::ECMP,
		CSimpleVM::EJGE, 0x58, CSimpleVM::EPSH_MEM8, 0xAD,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::EXOR,
		CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ERSHIFT, 7,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,CSimpleVM::ELSHIFT, 1,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_MEM16, 0x00, 0x01, CSimpleVM::EPSH_MEM16,
		0x00, 0x01,CSimpleVM::EPSH_EDX, CSimpleVM::EPSH_EBX,
		CSimpleVM::EMOD, CSimpleVM::ELDDSB,
		CSimpleVM::EPSH_ESI,CSimpleVM::ELDSB,
		CSimpleVM::ESUB, CSimpleVM::EADD, CSimpleVM::EMOD,
		CSimpleVM::EPOP_ESI_P, CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,
		CSimpleVM::ENOT, CSimpleVM::EPSH_MEM8, 0x7B,
		CSimpleVM::EAND, CSimpleVM::EPSH_MEM8, 0x7B, CSimpleVM::ENOT,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::EAND,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB, CSimpleVM::ERSHIFT, 4,
		CSimpleVM::EPSH_ESI, CSimpleVM::ELDSB,  CSimpleVM::ELSHIFT, 4,
		CSimpleVM::EOR, CSimpleVM::EPOP_ESI_P, CSimpleVM::EINC_EBX,
		CSimpleVM::EJMP, 0x18, 0
	};

	typedef struct _VMCONTEXT
	{
		DWORD _eax;
		DWORD _ebx;
		DWORD _ecx;
		DWORD _edx;
		DWORD _esi;
		DWORD _edi;
		DWORD _esp;
		DWORD _ebp;  // _ebp被用作临时寄存器，不用恢复到真实寄存器中
		DWORD _flags;
		//DWORD _SF;
		//DWORD _CF;
		//DWORD _OF;
		DWORD _eip;
	}VMCONTEXT;
	byte VMStack[0x200] = { 0 };
	VMCONTEXT VMContext = { 0 };
	DWORD VMBegin = 0;
	DWORD VMTemp = 0;
	enum E_VMP:BYTE {
		Vjnz = 0x94, Vjnb = 0x93, VpopRegMem16 = 0x83, Vor32 = 0x8F, Vmul32 = 0x86, Vxor32 = 0x8E, VpushRegMem32 = 0x7B, VpopMem32 = 0x81, VsaveReg32 = 0x87, Vsub32 = 0x97, VpopReg16 = 0x7D, Vcmp8 = 0x8A, Vjmp = 0x95, Vstos = 0x90, VpushMem16 = 0x77, Vnop = 0x96, Vshr = 0x9B, VpushImm32 = 0x75, Vshl = 0x9A, VpopRegMem32 = 0x84, VjmpEsp = 0x89, VpushReg8 = 0x70, Vadd32 = 0x85, VpushImm8 = 0x73, Vcmp32 = 0x8B, VpopReg8 = 0x7C, VpushRegMem16 = 0x7A, VpushRegMem8 = 0x79, VpopMem16 = 0x80, Vtest8 = 0x9E, VpopReg1632 = 0x98, VpushReg16 = 0x71, VpopReg832 = 0x99, VpopReg32 = 0x7E, VpushReg32 = 0x72, Vjz = 0x91, VpushMem32 = 0x78, VpopMem8 = 0x7F, VloadReg32 = 0x88, Vand32 = 0x9D, Vja = 0x92, VpushMem8 = 0x76, Vnot32 = 0x8D, VpushImm16 = 0x74, VpopRegMem8 = 0x82, Vdiv32 = 0x9C, Vretn = 0x9F, Vsetl=0xa0, VpushCF32=0xa1, VjmpMem32=0xa2
	};
	
	/*******************************************************/
	// 复制VM.txt中的数据后，再用OD手工查找dwJmpTbl的地址，
	// 修改0xFFFFFFFF为虚跳转表的地址。
	// 此处要保证VMCode具有足够的空间，否则会崩溃。
	byte VMCode[0x1000] = {
		0x72,0x74,0x78,0x20,0xC5,0x48,0x00,0x7E,0x74,0x79,0x74,0x7C,0x70,0x70,0x70,0x70,0x70,0x9E,0x91,0xE4,0x06,0x00,0x00,0x72,0x75,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x96,0x70,0x70,0x99,0x70,0x75,0x44,0xFF,0xFF,0xFF,0x72,0x70,0x85,0x7E,0x70,0x75,0x1E,0x00,0x00,0x00,0x72,0x70,0x8B,0x92,0xD4,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x70,0x86,0x75,0xB8,0x88,0x40,0x00,0x85,0x7E,0x77,0x7B,0x77,0x89,0x78,0x04,0xC5,0x48,0x00,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x70,0x81,0x04,0xC5,0x48,0x00,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x78,0x18,0xC5,0x48,0x00,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x78,0x1C,0xC5,0x48,0x00,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x70,0x81,0x18,0xC5,0x48,0x00,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x70,0x81,0x1C,0xC5,0x48,0x00,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x70,0x81,0x0C,0xC5,0x48,0x00,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x70,0x81,0x10,0xC5,0x48,0x00,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x78,0x10,0xC5,0x48,0x00,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x75,0x01,0x00,0x00,0x00,0x78,0x08,0xC5,0x48,0x00,0x85,0x81,0x08,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x72,0x70,0x8B,0xA1,0x72,0x70,0x85,0x72,0x70,0x97,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x70,0x85,0x7E,0x70,0x75,0x02,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x70,0x81,0x2C,0xC5,0x48,0x00,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x95,0xC3,0x06,0x00,0x00,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x20,0xC5,0x48,0x00,0x7E,0x74,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x75,0x05,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x74,0x95,0xCD,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x7B,0x77,0x8E,0x84,0x77,0x95,0xA4,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x7B,0x77,0x8F,0x84,0x77,0x95,0xA4,0x06,0x00,0x00,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x77,0x79,0x77,0x99,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x20,0xC5,0x48,0x00,0x7E,0x74,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x75,0x02,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x74,0x95,0xCD,0x06,0x00,0x00,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x77,0x7A,0x77,0x98,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x20,0xC5,0x48,0x00,0x7E,0x74,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x75,0x03,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x74,0x95,0xCD,0x06,0x00,0x00,0x75,0x01,0x00,0x00,0x00,0x78,0x2C,0xC5,0x48,0x00,0x8B,0x94,0x0F,0x04,0x00,0x00,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x77,0x79,0x77,0x99,0x74,0x78,0x30,0xC5,0x48,0x00,0x72,0x74,0x85,0x7E,0x74,0x95,0xCD,0x06,0x00,0x00,0x75,0x02,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x74,0x95,0xCD,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x79,0x77,0x7C,0x73,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x78,0x18,0xC5,0x48,0x00,0x7E,0x72,0x78,0x08,0xC5,0x48,0x00,0x7E,0x70,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x72,0x72,0x72,0x70,0x85,0x7E,0x77,0x70,0x73,0x82,0x77,0x95,0xC3,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x79,0x77,0x7C,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x77,0x79,0x77,0x7C,0x72,0x70,0x72,0x70,0x70,0x9A,0x7C,0x70,0x70,0x70,0x99,0x70,0x95,0x61,0x03,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x79,0x77,0x99,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x77,0x79,0x77,0x7C,0x72,0x70,0x72,0x72,0x70,0x9B,0x7E,0x70,0x95,0x61,0x03,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x72,0x73,0x72,0x73,0x8E,0x7E,0x73,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x72,0x70,0x9C,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x72,0x73,0x84,0x77,0x95,0xA4,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x7B,0x77,0x85,0x84,0x77,0x95,0xA4,0x06,0x00,0x00,0x78,0x08,0xC5,0x48,0x00,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x72,0x72,0x72,0x72,0x70,0x85,0x7E,0x77,0x79,0x77,0x99,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x78,0x1C,0xC5,0x48,0x00,0x7E,0x70,0x95,0x41,0x05,0x00,0x00,0x78,0x0C,0xC5,0x48,0x00,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x78,0x08,0xC5,0x48,0x00,0x7E,0x70,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x85,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x72,0x70,0x97,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x95,0xA4,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x79,0x77,0x99,0x70,0x72,0x70,0x8D,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x95,0xBC,0x06,0x00,0x00,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0x00,0xC2,0x48,0x00,0x85,0x7E,0x77,0x7B,0x77,0x7E,0x70,0x75,0x04,0x00,0x00,0x00,0x72,0x75,0x86,0x75,0xFC,0xC1,0x48,0x00,0x85,0x7E,0x77,0x72,0x70,0x7B,0x77,0x9D,0x84,0x77,0x78,0x14,0xC5,0x48,0x00,0x7E,0x75,0x75,0x01,0x00,0x00,0x00,0x72,0x75,0x97,0x7E,0x75,0x72,0x75,0x81,0x14,0xC5,0x48,0x00,0x78,0x20,0xC5,0x48,0x00,0x7E,0x74,0x75,0x01,0x00,0x00,0x00,0x72,0x74,0x85,0x7E,0x74,0x72,0x74,0x81,0x20,0xC5,0x48,0x00,0x79,0x74,0x7C,0x70,0x70,0x70,0x70,0x70,0x9E,0x94,0x21,0x00,0x00,0x00,0x7E,0x75,0x7E,0x74,0x9F
	};

	// 加入一个虚跳转表，VM1的所有switch虚跳转。  
	DWORD dwVJmpTbl[32] = { 
		0x004F, 0x00B8, 0x00F0, 0x0087, 0x0128, 0x0159, 0x0292, 0x0224, 0x0239, 0x03E2, 0x02E2, 0x0679, 0x0640, 0x0312, 0x04C1, 0x058C, 0x01EC, 0x018A, 0x01BB, 0x05C4, 0x03F2, 0x053A, 0x0461, 0x0493, 0x0342, 0x041E, 0x06D4, 0x0580, 0x050A, 0x0392, 0x05FC
	};

	CSimpleVM::CSimpleVM()
	{
		
	}


	CSimpleVM::~CSimpleVM()
	{
	}

	void CSimpleVM::InitSelf(DWORD dwESI, int dwECX, DWORD dwEDI, int dwEDX, E_DIR ed)
	{
		//memset(Stack, 0, 0x100 * sizeof(DWORD));
		for (int i = 0; i < 0x100; i++)
			Stack[i] = 0;
		ESP = -1;

		switch (ed)
		{
		case E_ENC1:
			OEP = EIP = (DWORD)op_encrypt1;
			*(PDWORD)(&op_encrypt1[1]) = dwESI;
			*(PINT)&op_encrypt1[7] = dwECX;
			*(PDWORD)&op_encrypt1[13] = dwEDI;
			*(PINT)&op_encrypt1[19] = dwEDX;
			break;
		case E_ENC3:
			OEP = EIP = (DWORD)op_encrypt3;
			*(PDWORD)&op_encrypt3[1] = dwESI;
			*(PINT)&op_encrypt3[7] = dwECX;
			*(PDWORD)&op_encrypt3[13] = dwEDI;
			*(PINT)&op_encrypt3[19] = dwEDX;
			break;
		case E_DEC2:
			OEP = EIP = (DWORD)op_decrypt2;
			*(PDWORD)&op_decrypt2[1] = dwESI;
			*(PINT)&op_decrypt2[7] = dwECX;
			*(PDWORD)&op_decrypt2[13] = dwEDI;
			*(PINT)&op_decrypt2[19] = dwEDX;
			break;
		case E_DEC1:
			OEP = EIP = (DWORD)op_decrypt1;
			*(PDWORD)&op_decrypt1[1] = dwESI;
			*(PINT)&op_decrypt1[7] = dwECX;
			*(PDWORD)&op_decrypt1[13] = dwEDI;
			*(PINT)&op_decrypt1[19] = dwEDX;
			break;
		case E_ENC2:
			OEP = EIP = (DWORD)op_encrypt2;
			*(PDWORD)&op_encrypt2[1] = dwESI;
			*(PINT)&op_encrypt2[7] = dwECX;
			*(PDWORD)&op_encrypt2[13] = dwEDI;
			*(PINT)&op_encrypt2[19] = dwEDX;
			break;
		case E_DEC3:
			OEP = EIP = (DWORD)op_decrypt3;
			*(PDWORD)&op_decrypt3[1] = dwESI;
			*(PINT)&op_decrypt3[7] = dwECX;
			*(PDWORD)&op_decrypt3[13] = dwEDI;
			*(PINT)&op_decrypt3[19] = dwEDX;
			break;
		}
		//if (ed == E_ENC1)
		//{
		//	OEP = EIP = (DWORD)op_encrypt1;
		//	*(PDWORD)(&op_encrypt1[1]) = dwESI;
		//	*(PINT)&op_encrypt1[7] = dwECX;
		//	*(PDWORD)&op_encrypt1[13] = dwEDI;
		//	*(PINT)&op_encrypt1[19] = dwEDX;
		//}
		//else if (E_ENC2 == ed)
		//{
		//	OEP = EIP = (DWORD)op_encrypt2;
		//	*(PDWORD)&op_encrypt2[1] = dwESI;
		//	*(PINT)&op_encrypt2[7] = dwECX;
		//	*(PDWORD)&op_encrypt2[13] = dwEDI;
		//	*(PINT)&op_encrypt2[19] = dwEDX;
		//}
		//else if (E_ENC3 == ed)
		//{
		//	OEP = EIP = (DWORD)op_encrypt3;
		//	*(PDWORD)&op_encrypt3[1] = dwESI;
		//	*(PINT)&op_encrypt3[7] = dwECX;
		//	*(PDWORD)&op_encrypt3[13] = dwEDI;
		//	*(PINT)&op_encrypt3[19] = dwEDX;
		//}
		//else if (E_DEC1 == ed)
		//{
		//	OEP = EIP = (DWORD)op_decrypt1;
		//	*(PDWORD)&op_decrypt1[1] = dwESI;
		//	*(PINT)&op_decrypt1[7] = dwECX;
		//	*(PDWORD)&op_decrypt1[13] = dwEDI;
		//	*(PINT)&op_decrypt1[19] = dwEDX;
		//}
		//else if (E_DEC2 == ed)
		//{
		//	OEP = EIP = (DWORD)op_decrypt2;
		//	*(PDWORD)&op_decrypt2[1] = dwESI;
		//	*(PINT)&op_decrypt2[7] = dwECX;
		//	*(PDWORD)&op_decrypt2[13] = dwEDI;
		//	*(PINT)&op_decrypt2[19] = dwEDX;
		//}
		//else if (E_DEC3 == ed)
		//{
		//	OEP = EIP = (DWORD)op_decrypt3;
		//	*(PDWORD)&op_decrypt3[1] = dwESI;
		//	*(PINT)&op_decrypt3[7] = dwECX;
		//	*(PDWORD)&op_decrypt3[13] = dwEDI;
		//	*(PINT)&op_decrypt3[19] = dwEDX;
		//}
	}

	void CSimpleVM::Execute()
	{
#ifdef __VM2__
		__asm {
			mov VMContext._eax, eax
			mov VMContext._ebx, ebx
			mov VMContext._ecx, ecx
			mov VMContext._edx, edx
			mov VMContext._esi, esi
			mov VMContext._edi, edi
			mov VMContext._ebp, ebp
			lea eax, VMStack
			add eax, 200h
			mov VMContext._esp, eax
			lea eax, VMCode
			mov VMBegin, eax
			mov VMContext._eip, eax
		}
#else
		while (*(PBYTE)EIP)
		{
			switch (*(PBYTE)EIP)
			{
			case EPSH_EAX: Push_EAX(); break;
			case EPOP_EAX: Pop_EAX();  break;
			case EPSH_ESI: Push_ESI(); break;
			case EPSH_EDI: Push_EDI(); break;
			case EPOP_ESI: Pop_ESI();  break;
			case EPOP_EDI: Pop_EDI();  break;
			case EPOP_ECX: Pop_ECX();  break;
			case EPOP_EDX: Pop_EDX();  break;
			case EPSH_EDX: Push_EDX(); break;
			case EINC_EBX: Inc_EBX();  break;
			case ECMP: Cmp(); break;
			case EPSH_MEM: Push_MEM(); break;
			case EXOR: Xor(); break;
			case EOR: Or(); break;
			case EPSH_MEM8:	Push_MEM8(); break;
			case EPSH_MEM16: Push_MEM16(); break;
			case EJGE: JGE(); break;
			case EPOP_ESI_P: Pop_ESI_P(); break;
			case EJMP: JMP(); break;
			case ELSHIFT: LSHIFT(); break;
			case ERSHIFT: RSHIFT(); break;
			case EMOD: Mod(); break;
			case EADD: Add(); break;
			case ELDSB: LdSB(); break;
			case ELDDSB: LdDSB(); break;
			case EPSH_ECX: Push_ECX(); break;
			case EPSH_EBX: Push_EBX(); break;
			case ESUB: Sub(); break;
			case ENOT: Not(); break;
			case EAND: And(); break;
			default: break;
			}
		}
#endif
#ifdef __VM2__
		// 由于使用switch编译器会产生跳转表，引起Stack数据偏移。
		while (TRUE)
		{
			switch (*(PBYTE)VMContext._eip++)
			{
			case VpushImm8:
				*(PBYTE)(--VMContext._esp) = *(PBYTE)VMContext._eip;
				VMContext._eip++;
				break;
			case VpushImm16:
				VMContext._esp -= 2;
				*(PWORD)(VMContext._esp) = *(PWORD)VMContext._eip;
				VMContext._eip += 2;
				break;
			case VpushImm32:
				VMContext._esp -= 4;
				*(PDWORD)VMContext._esp = *(PDWORD)VMContext._eip;
				VMContext._eip += 4;
				break;
			case VpushReg8:
				*(PBYTE)(--VMContext._esp) = (BYTE)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip-0x70));
				VMContext._eip++;
				break;
			case VpushReg16:
				VMContext._esp -= 2;
				*(PWORD)VMContext._esp = (WORD)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70));
				VMContext._eip++;
				break;
			case VpushReg32:
				VMContext._esp -= 4;
				*(PDWORD)VMContext._esp = *((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70));
				VMContext._eip++;
				break;
			case VpushMem8:
				// 取后面指向的地址中的内容
				*(PBYTE)(--VMContext._esp) = *(PBYTE)(*(PDWORD)VMContext._eip);
				VMContext._eip++;
				break;
			case VpushCF32:
				VMContext._esp -= 4;
				if (VMContext._flags & 0x1)
					*(PDWORD)VMContext._esp = 1;
				else
					*(PDWORD)VMContext._esp = 0;
				break;
			case VpushMem16:
				// 取后面指向的地址中的内容
				VMContext._esp -= 2;
				*(PWORD)VMContext._esp = *(PWORD)(*(PDWORD)VMContext._eip);
				VMContext._eip += 2;
				break;
			case VpushMem32:
				// 取后面指向的地址中的内容
				VMContext._esp -= 4;
				*(PDWORD)VMContext._esp = *(PDWORD)(*(PDWORD)VMContext._eip);
				VMContext._eip += 4;
				break;
			case VpushRegMem8:
				// 取虚寄存器指向地址中的内容
				*(PBYTE)(--VMContext._esp) = *(PBYTE)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70));
				VMContext._eip++;
				break;
			case VpushRegMem16:
				VMContext._esp -= 2;
				// 取虚寄存器指向地址中的内容
				*(PWORD)VMContext._esp = *(PWORD)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70));
				VMContext._eip++;
				break;
			case VpushRegMem32:
				// 取虚寄存器指向地址中的内容
				VMContext._esp -= 4;
				*(PDWORD)VMContext._esp = *(PDWORD)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70));
				VMContext._eip++;
				break;
			case VpopReg8:
				*(PBYTE)((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = *(PBYTE)VMContext._esp++;
				VMContext._eip++;
				break;
			case VpopReg16:
				*(PWORD)((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = *(PWORD)VMContext._esp;
				VMContext._esp += 2;
				VMContext._eip++;
				break;
			case VpopReg32:
				*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = *(PDWORD)VMContext._esp;
				VMContext._esp += 4;
				VMContext._eip++;
				break;
			case VpopMem8:
				*(PBYTE)(*(PDWORD)VMContext._eip) = *(PBYTE)VMContext._esp++;
				VMContext._eip++;
				break;
			case VpopMem16:
				*(PWORD)(*(PDWORD)VMContext._eip) = *(PWORD)VMContext._esp;
				VMContext._esp += 2;
				VMContext._eip += 2;
				break;
			case VpopMem32:
				*(PDWORD)(*(PDWORD)VMContext._eip) = *(PDWORD)VMContext._esp;
				VMContext._esp += 4;
				VMContext._eip += 4;
				break;
			case VpopRegMem8:
				*(PBYTE)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = *(PBYTE)VMContext._esp++;
				VMContext._eip++;
				break;
			case VpopRegMem16:
				*(PWORD)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = *(PWORD)VMContext._esp;
				VMContext._esp += 2;
				VMContext._eip++;
				break;
			case VpopRegMem32:
				*(PDWORD)*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = *(PDWORD)VMContext._esp;
				VMContext._esp += 4;
				VMContext._eip++;
				break;
			case Vadd32:
				*(PDWORD)(VMContext._esp + 4) = (*(PDWORD)VMContext._esp) + (*(PDWORD)(VMContext._esp + 4));
				VMContext._esp += 4;
				break;
			case Vmul32:
				*(PDWORD)(VMContext._esp + 4) = (*(PDWORD)VMContext._esp) * (*(PDWORD)(VMContext._esp + 4));
				VMContext._esp += 4;
				break;
			case Vsub32:
				*(PDWORD)(VMContext._esp + 4) = (*(PDWORD)VMContext._esp) - (*(PDWORD)(VMContext._esp + 4));
				VMContext._esp += 4;
				break;
			case VsaveReg32:
				VMTemp = *((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70));
				VMContext._eip++;
				break;
			case VjmpMem32:
				VMContext._eip = VMBegin + *(PDWORD)VMContext._esp;
				VMContext._esp += 4;
				break;
			case VloadReg32:
				*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = VMTemp;
				VMContext._eip++;
				break;
			case Vcmp8:
				__asm
				{
					mov ebx, VMContext._esp
					mov dl, byte ptr[ebx]; dst oprand
					cmp dl, byte ptr[ebx +1]; src oprand
					pushfd
					pop VMContext._flags
					add VMContext._esp, 2
	/*				pop eax
					mov ecx, eax; save fd
					and eax, 00000001h; CF
					mov VMContext._CF, eax
					mov eax, ecx
					and eax, 00000040h; ZF
					mov VMContext._ZF, eax
					mov eax, ecx
					and eax, 00000080h; SF
					mov VMContext._SF, eax
					mov eax, ecx
					and eax, 00000800h; OF
					mov VMContext._OF, eax*/
				}
				break;
			case Vcmp32:
				__asm {
					mov ebx, VMContext._esp
					mov edx, dword ptr[ebx]; dst oprand
					cmp edx, dword ptr[ebx + 4]
					pushfd
					pop VMContext._flags
					add VMContext._esp, 8
/*					pop eax
					mov ecx, eax; save fd
					and eax, 00000001h; CF
					mov VMContext._CF, eax
					mov eax, ecx
					and eax, 00000040h; ZF
					mov VMContext._ZF, eax
					mov eax, ecx
					and eax, 00000080h; SF
					mov VMContext._SF, eax
					mov eax, ecx
					and eax, 00000800h; OF
					mov VMContext._OF, eax*/
				}
				break;
			case VpopReg832:
				*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = (DWORD)*(PBYTE)VMContext._esp++;
				VMContext._eip++;
				break;
			case VpopReg1632:
				*((PDWORD)&VMContext + (*(PBYTE)VMContext._eip - 0x70)) = (DWORD)*(PWORD)VMContext._esp;
				VMContext._esp += 2;
				VMContext._eip++;
				break;
			case Vnot32:
				*(PDWORD)VMContext._esp = ~*(PDWORD)VMContext._esp;
				break;
			case Vxor32:
				*(PDWORD)(VMContext._esp + 4) = ((*(PDWORD)VMContext._esp) ^ (*(PDWORD)(VMContext._esp + 4)));
				VMContext._esp += 4;
				break;
			case Vor32:
				*(PDWORD)(VMContext._esp + 4) = ((*(PDWORD)VMContext._esp) | (*(PDWORD)(VMContext._esp + 4)));
				VMContext._esp += 4;
				break;
			case Vstos:
				__asm
				{
					mov eax, VMContext._eax
					mov ecx, VMContext._ecx
					mov edi, VMContext._edi
					mov esi, VMContext._esi
					rep stosd
					mov VMContext._eax, eax
					mov VMContext._ecx, ecx
					mov VMContext._edi, edi
					mov VMContext._esi, esi
				}
				break;
			case Vjz:
				if (VMContext._flags & 0x40)
					VMContext._eip = VMBegin + *(PDWORD)VMContext._eip;
				else
					VMContext._eip += 4;
				break;
			case Vja:
				if (0 == (VMContext._flags & 0x41))
					VMContext._eip = VMBegin + *(PDWORD)VMContext._eip;
				else
					VMContext._eip += 4;
				break;
			case Vjnz:
				if (0 == (VMContext._flags & 0x40))
					VMContext._eip = VMBegin + *(PDWORD)VMContext._eip;
				else
					VMContext._eip += 4;
				break;
			case Vjnb: //等价于jnc (jb == jc)
				if (0 == (VMContext._flags & 0x1))
					VMContext._eip = VMBegin + *(PDWORD)VMContext._eip;
				else
					VMContext._eip += 4;
				break;
			case Vjmp:
				VMContext._eip = VMBegin + *(PDWORD)VMContext._eip;
				break;
			case Vnop:
				break;
			case Vshl: //shl reg8, reg8
				*(PBYTE)(VMContext._esp+1) = ((*(PBYTE)(VMContext._esp)) << (*(PBYTE)(VMContext._esp+1)));
				VMContext._esp++;
				break;
			case Vshr: //shr reg32, reg8
				*(PDWORD)(VMContext._esp + 1) = ((*(PDWORD)(VMContext._esp)) >> (*(PBYTE)(VMContext._esp + 4)));
				VMContext._esp++;
				break;
			case Vand32:
				*(PDWORD)(VMContext._esp + 4) = ((*(PDWORD)VMContext._esp) & (*(PDWORD)(VMContext._esp + 4)));
				VMContext._esp += 4;
				break;
			case Vdiv32:
				__asm
				{
					mov ebx, VMContext._esp
					mov eax, dword ptr[ebx]
					cdq
					div dword ptr[ebx + 4]
					mov VMContext._eax, eax
					mov VMContext._edx, edx
					add VMContext._esp, 8
				}
				break;
			case Vtest8: // test al, al
				__asm
				{
					mov ebx, VMContext._esp
					mov dl, byte ptr[ebx]; dst oprand
					test dl, byte ptr[ebx+1]; src oprand
					//test dl, cl
					pushfd
					pop VMContext._flags
					add VMContext._esp, 2
					//mov ecx, eax; save fd
					//and eax, 00000001h; CF
					//mov VMContext._CF, eax
					//mov eax, ecx
					//and eax, 00000040h; ZF
					//mov VMContext._ZF, eax
					//mov eax, ecx
					//and eax, 00000080h; SF
					//mov VMContext._SF, eax
					//mov eax, ecx
					//and eax, 00000800h; OF
					//mov VMContext._OF, eax
					//pop eax
					//pop ecx
					//pop edx
					//pop ebx
				}
				break;
			case Vretn:
				__asm
				{
					mov eax, VMContext._eax
					mov ebx, VMContext._ebx
					mov ecx, VMContext._ecx
					mov edx, VMContext._edx
					mov esi, VMContext._esi
					mov edi, VMContext._edi
				}
				return;
				break;
			case VjmpEsp:
				VMContext._eip = VMBegin + *(PDWORD)VMContext._esp;
				VMContext._esp += 4;
				break;
		default:
			VMTemp = VMContext._eip;
			MessageBox(NULL, L"cant execute target pcode!", L"error", MB_OK);
			ExitProcess(-1);
			break;
			}
		}
#endif	
	}

	__forceinline void CSimpleVM::LdSB()
	{
		Stack[ESP] = ((PBYTE)Stack[ESP])[EBX];
		EIP++;
		//printf("EIP = %X", EIP);
		//printf("LdSB %X\n", EAX);
	}

	__forceinline void CSimpleVM::Push_EAX()
	{
		Stack[++ESP] = EAX;
		EIP++;
	}

	__forceinline void CSimpleVM::Push_ESI()
	{
		Stack[++ESP] = ESI;
		EIP++;
		//printf("Push_ESI %X\n", EAX);
	}

	__forceinline void CSimpleVM::Push_EDI()
	{
		Stack[++ESP] = EDI;
		EIP++;
	}

	__forceinline void CSimpleVM::Push_MEM16()
	{
		Stack[++ESP] = *(PWORD)(EIP + 1);
		EIP += 3;
		//printf("push mem16, [esp]=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Push_MEM()
	{
		Stack[++ESP] = *(PDWORD)(EIP + 1);
		EIP += 5;
		//printf("push mem, [esp]=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Push_MEM8()
	{
		Stack[++ESP] = *(PBYTE)(EIP + 1);
		EIP += 2;
		//printf("push mem8, [esp]=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Push_ECX()
	{
		Stack[++ESP] = ECX;
		EIP++;
		//printf("push_ecx, %X", EAX);
	}

	__forceinline void CSimpleVM::Push_EDX()
	{
		Stack[++ESP] = EDX;
		EIP++;
		//printf("push_edx, eax=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Pop_ECX()
	{
		ECX = Stack[ESP--];
		EIP++;
		//printf("pop ecx, ecx=%X\n", ECX);
	}
	__forceinline void CSimpleVM::Pop_EDX()
	{
		EDX = Stack[ESP--];
		EIP++;
		//printf("pop edx, edx=%X\n", EDX);
	}

	__forceinline void CSimpleVM::Pop_EAX()
	{
		EAX = Stack[ESP--];
		EIP++;
	} 

	__forceinline void CSimpleVM::Push_EBX()
	{
		Stack[++ESP] = EBX;
		EIP++;
		//printf("push_ebx, [ESP]=0x%X\n", EAX);
	}

	__forceinline void CSimpleVM::Pop_ESI()
	{
		ESI = Stack[ESP--];
		EIP++;
		//printf("pop esi, esi=%X\n", ESI);
	}

	__forceinline void CSimpleVM::Pop_EDI()
	{
		EDI = Stack[ESP--];
		EIP++;
		//printf("pop edi, edi=%X\n", EDI);
	}

	__forceinline void CSimpleVM::Cmp()
	{
		if (Stack[ESP] >= Stack[ESP-1])
			ESF = 1;
		else
			ESF = 0;	
		ESP-=2;
		EIP++;
		//printf("CMP SF=%X, ZF=%X\n", ESF, EZF);
	}	

	__forceinline void CSimpleVM::JGE()
	{
		if (1 == ESF)
			EIP = OEP + *(PBYTE)(EIP+1);
		else
			EIP += 2;
		//printf("JGE %X\n", EAX);
	}

	__forceinline void CSimpleVM::JMP()
	{
		EIP = OEP+(DWORD)*(PBYTE)(EIP+1);
		//EIP = EAX;
		//printf("JMP %X\n", EAX);
	}

	__forceinline void CSimpleVM::Xor()
	{
		Stack[ESP - 1] = (Stack[ESP] ^ Stack[ESP - 1]);
		ESP--;
		//EAX = Stack[ESP--];
		//EAX ^= Stack[ESP];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("XOR EAX=%X\n", EAX);
	}

	__forceinline void CSimpleVM::And()
	{
		Stack[ESP - 1] = (Stack[ESP] & Stack[ESP - 1]);
		ESP--;
		//EAX = Stack[ESP--];
		//EAX &= Stack[ESP];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("AND EAX=%X", EAX);
	}

	__forceinline void CSimpleVM::Add()
	{
		Stack[ESP - 1] = Stack[ESP] + Stack[ESP - 1];
		ESP--;
		//EAX = Stack[ESP--];
		//EAX += Stack[ESP];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("Add EAX=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Mod()
	{
		Stack[ESP - 1] = (Stack[ESP] % Stack[ESP - 1]);
		ESP--;
		//EAX = Stack[ESP--];
		//EAX %= Stack[ESP];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("Mod EAX=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Sub()
	{
		Stack[ESP - 1] = Stack[ESP] - Stack[ESP - 1];
		ESP--;
		//EAX = Stack[ESP--];
		//EAX -= Stack[ESP];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("Sub EAX=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Not()
	{
		// 此处实际相当于对1个字节进行取反
		Stack[ESP] = ~LOBYTE(Stack[ESP]);
		//Stack[ESP] = EAX;
		EIP++;
	}

	__forceinline void CSimpleVM::Or()
	{
		Stack[ESP - 1] = (Stack[ESP] | Stack[ESP - 1]);
		ESP--;
		//EAX = Stack[ESP--];
		//EAX |= Stack[ESP];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("OR, EAX=%X", EAX);
	}

	__forceinline void CSimpleVM::LSHIFT()
	{
		//EAX = Stack[ESP];
		Stack[ESP] = LOBYTE((LOBYTE(Stack[ESP])) << (*(PBYTE)(EIP + 1)));
		//EAX = LOBYTE(EAX);
		//Stack[ESP] = LOBYTE(EAX);
		EIP+=2;
		//printf("LSHIFT, eax=%X\n", EAX);
	}

	__forceinline void CSimpleVM::RSHIFT()
	{
		Stack[ESP] = ((LOBYTE(Stack[ESP]) >> (*(PBYTE)(EIP + 1))));
		//EAX = Stack[ESP];
		//EAX >>= *(PBYTE)(EIP + 1);
		//EAX = LOBYTE(EAX);
		//Stack[ESP] = LOBYTE(EAX);  //EAX;
		EIP+=2;
		//printf("RSHIFT, eax=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Pop_ESI_P()
	{
		//EAX = Stack[ESP--];
		((PBYTE)ESI)[EBX] = (BYTE)Stack[ESP--];
		EIP++;
		//printf("Pop_ESI_p EAX=%X\n", EAX);
	}

	__forceinline void CSimpleVM::LdDSB()
	{
		//EAX = Stack[ESP];
		Stack[ESP] = ((PBYTE)EDI)[Stack[ESP]];
		//Stack[ESP] = EAX;
		EIP++;
		//printf("LdDBS, [ESP]=%X\n", EAX);
	}

	__forceinline void CSimpleVM::Inc_EBX()
	{
		//EAX = EBX;
		//EAX++;
		//EBX = EAX;
		EBX++;
		EIP++;
		//printf("Inc_EBX, EAX=%X\n", EAX);
	}
}
